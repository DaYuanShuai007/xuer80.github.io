<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    
    <title>第三章-Kotlin编码规范 | Xuer80</title>
    
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    
        <meta name="keywords" content="kotlin" />
    
    <meta name="description" content="源代码组织目录结构在混合语言项目中，Kotlin 源文件应当与 Java 源文件位于同一源文件根目录下， 并遵循相同的目录结构（每个文件应存储在与其 package 语句对应的目录中 ）。 在纯 Kotlin 项目中，推荐的目录结构遵循省略了公共根包的包结构 （例如，如果项目中的所有代码都位于“org.example.kotlin”包及其子包中，那么“org.example.kotlin”包的文件">
<meta name="keywords" content="kotlin">
<meta property="og:type" content="article">
<meta property="og:title" content="第三章-Kotlin编码规范">
<meta property="og:url" content="http://xuer80.com/2018/04/27/第三章-Kotlin编码规范/index.html">
<meta property="og:site_name" content="Xuer80">
<meta property="og:description" content="源代码组织目录结构在混合语言项目中，Kotlin 源文件应当与 Java 源文件位于同一源文件根目录下， 并遵循相同的目录结构（每个文件应存储在与其 package 语句对应的目录中 ）。 在纯 Kotlin 项目中，推荐的目录结构遵循省略了公共根包的包结构 （例如，如果项目中的所有代码都位于“org.example.kotlin”包及其子包中，那么“org.example.kotlin”包的文件">
<meta property="og:locale" content="zh-CN">
<meta property="og:updated_time" content="2018-04-27T15:34:30.226Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="第三章-Kotlin编码规范">
<meta name="twitter:description" content="源代码组织目录结构在混合语言项目中，Kotlin 源文件应当与 Java 源文件位于同一源文件根目录下， 并遵循相同的目录结构（每个文件应存储在与其 package 语句对应的目录中 ）。 在纯 Kotlin 项目中，推荐的目录结构遵循省略了公共根包的包结构 （例如，如果项目中的所有代码都位于“org.example.kotlin”包及其子包中，那么“org.example.kotlin”包的文件">
    

    

    

    <link rel="stylesheet" href="/libs/font-awesome/css/font-awesome.min.css">
    <link rel="stylesheet" href="/libs/titillium-web/styles.css">
    <link rel="stylesheet" href="/libs/source-code-pro/styles.css">

    <link rel="stylesheet" href="/css/style.css">

    <script src="/libs/jquery/2.0.3/jquery.min.js"></script>
    
    
        <link rel="stylesheet" href="/libs/lightgallery/css/lightgallery.min.css">
    
    
        <link rel="stylesheet" href="/libs/justified-gallery/justifiedGallery.min.css">
    
    
    
        <script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?5afbe52ffe1cab6bf0db3773c7af2e11";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>
    


</head>

<body>
    <div id="wrap">
        <header id="header">
    <div id="header-outer" class="outer">
        <div class="container">
            <div class="container-inner">
                <div id="header-title">
                    <h1 class="logo-wrap">
                        <a href="/" class="logo"></a>
                    </h1>
                    
                        <h2 class="subtitle-wrap">
                            <p class="subtitle">大道无为</p>
                        </h2>
                    
                </div>
                <div id="header-inner" class="nav-container">
                    <a id="main-nav-toggle" class="nav-icon fa fa-bars"></a>
                    <div class="nav-container-inner">
                        <ul id="main-nav">
                            
                                <li class="main-nav-list-item" >
                                    <a class="main-nav-list-link" href="/">主页</a>
                                </li>
                            
                                        <ul class="main-nav-list"><li class="main-nav-list-item"><a class="main-nav-list-link" href="/categories/Android/">Android</a><ul class="main-nav-list-child"><li class="main-nav-list-item"><a class="main-nav-list-link" href="/categories/Android/Android应用层/">Android应用层</a></li><li class="main-nav-list-item"><a class="main-nav-list-link" href="/categories/Android/Android框架层/">Android框架层</a></li></ul></li><li class="main-nav-list-item"><a class="main-nav-list-link" href="/categories/屠龙技/">屠龙技</a><ul class="main-nav-list-child"><li class="main-nav-list-item"><a class="main-nav-list-link" href="/categories/屠龙技/数据结构与算法/">数据结构与算法</a></li><li class="main-nav-list-item"><a class="main-nav-list-link" href="/categories/屠龙技/设计模式/">设计模式</a></li></ul></li><li class="main-nav-list-item"><a class="main-nav-list-link" href="/categories/开发工具/">开发工具</a><ul class="main-nav-list-child"><li class="main-nav-list-item"><a class="main-nav-list-link" href="/categories/开发工具/AndroidStudio/">AndroidStudio</a></li><li class="main-nav-list-item"><a class="main-nav-list-link" href="/categories/开发工具/Git/">Git</a></li></ul></li><li class="main-nav-list-item"><a class="main-nav-list-link" href="/categories/操作系统/">操作系统</a><ul class="main-nav-list-child"><li class="main-nav-list-item"><a class="main-nav-list-link" href="/categories/操作系统/Linux/">Linux</a></li></ul></li><li class="main-nav-list-item"><a class="main-nav-list-link" href="/categories/散文/">散文</a></li><li class="main-nav-list-item"><a class="main-nav-list-link" href="/categories/编程语言/">编程语言</a><ul class="main-nav-list-child"><li class="main-nav-list-item"><a class="main-nav-list-link" href="/categories/编程语言/C/">C</a></li><li class="main-nav-list-item"><a class="main-nav-list-link" href="/categories/编程语言/Java/">Java</a></li><li class="main-nav-list-item"><a class="main-nav-list-link" href="/categories/编程语言/Kotlin/">Kotlin</a></li></ul></li></ul>
                                    
                                <li class="main-nav-list-item" >
                                    <a class="main-nav-list-link" href="/about/index.html">关于</a>
                                </li>
                            
                                <li class="main-nav-list-item" >
                                    <a class="main-nav-list-link" href="/booklist/index.html">书单</a>
                                </li>
                            
                        </ul>
                        <nav id="sub-nav">
                            <div id="search-form-wrap">

    <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="搜索"><input type="hidden" name="sitesearch" value="http://xuer80.com"></form>

</div>
                        </nav>
                    </div>
                </div>
            </div>
        </div>
    </div>
</header>
        <div class="container">
            <div class="main-body container-inner">
                <div class="main-body-inner">
                    <section id="main">
                        <div class="main-body-header">
    <h1 class="header">
    
    <a class="page-title-link" href="/categories/编程语言/">编程语言</a><i class="icon fa fa-angle-right"></i><a class="page-title-link" href="/categories/编程语言/Kotlin/">Kotlin</a><i class="icon fa fa-angle-right"></i><a class="page-title-link" href="/categories/编程语言/Kotlin/认识Kotlin/">认识Kotlin</a>
    </h1>
</div>
                        <div class="main-body-content">
                            <article id="post-第三章-Kotlin编码规范" class="article article-single article-type-post" itemscope itemprop="blogPost">
    <div class="article-inner">
        
            <header class="article-header">
                
    
        <h1 class="article-title" itemprop="name">
        第三章-Kotlin编码规范
        </h1>
    

            </header>
        
        
            <div class="article-meta">
                
    <div class="article-date">
        <a href="/2018/04/27/第三章-Kotlin编码规范/" class="article-date">
            <time datetime="2018-04-27T15:21:25.000Z" itemprop="datePublished">2018-04-27</time>
        </a>
    </div>

                
    <div class="article-tag">
        <i class="fa fa-tag"></i>
        <a class="tag-link" href="/tags/kotlin/">kotlin</a>
    </div>

            </div>
        
        
        <div class="article-entry" itemprop="articleBody">
            <h2 id="源代码组织"><a href="#源代码组织" class="headerlink" title="源代码组织"></a>源代码组织</h2><h3 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h3><p>在混合语言项目中，Kotlin 源文件应当与 Java 源文件位于同一源文件根目录下， 并遵循相同的目录结构（每个文件应存储在与其 package 语句对应的目录中 ）。</p>
<p>在纯 Kotlin 项目中，推荐的目录结构遵循省略了公共根包的包结构 （例如，如果项目中的所有代码都位于“org.example.kotlin”包及其子包中，那么“org.example.kotlin”包的文件应该直接放在源代码根目录下，而 “org.example.kotlin.foo.bar”中的文件应该放在源代码根目录下的“foo/bar”子目录中）。</p>
<h3 id="源文件名称"><a href="#源文件名称" class="headerlink" title="源文件名称"></a>源文件名称</h3><p>如果 Kotlin 文件包含单个类（以及可能相关的顶层声明），那么文件名应该与该类的名称相同，并追加 .kt 扩展名。如果文件包含多个类或只包含顶层声明， 那么选择一个描述该文件所包含内容的名称，并以此命名该文件。使用首字母大写的驼峰风格 （例如 <code>ProcessDeclarations.kt</code>）。</p>
<p>文件的名称应该描述文件中代码的作用。因此，应避免在文件名中使用诸如“Util”之类的无意义词语。</p>
<h3 id="源文件组织"><a href="#源文件组织" class="headerlink" title="源文件组织"></a>源文件组织</h3><p>鼓励多个声明（类、顶级函数或者属性）放在同一个 Kotlin 源文件中， 只要这些声明在语义上彼此紧密关联并且文件保持合理大小 （不超过几百行）。</p>
<p>特别是在为类定义与类的所有客户都相关的扩展函数时， 请将它们放在与类自身定义相同的地方。而在定义仅对指定客户有意义的扩展函数时，请将它们放在紧挨该客户代码之后。不要只是为了保存 “Foo 的所有扩展函数”而创建文件。</p>
<h3 id="类布局"><a href="#类布局" class="headerlink" title="类布局"></a>类布局</h3><p>通常，一个类的内容按以下顺序排列：</p>
<ul>
<li>属性声明与初始化块</li>
<li>次构造函数</li>
<li>方法声明</li>
<li>伴生对象</li>
</ul>
<p>不要按字母顺序或者可见性对方法声明排序，也不要将常规方法与扩展方法分开。而是要把相关的东西放在一起，这样从上到下阅读类的人就能够跟进所发生事情的逻辑。选择一个顺序（高级别优先，或者相反） 并坚持下去。</p>
<p>将嵌套类放在紧挨使用这些类的代码之后。如果打算在外部使用嵌套类，而且类中并没有引用这些类，那么把它们放到末尾，在伴生对象之后。</p>
<h3 id="接口实现布局"><a href="#接口实现布局" class="headerlink" title="接口实现布局"></a>接口实现布局</h3><p>在实现一个接口时，实现成员的顺序应该与该接口的成员顺序相同（如果需要， 还要插入用于实现的额外的私有方法）</p>
<h3 id="重载布局"><a href="#重载布局" class="headerlink" title="重载布局"></a>重载布局</h3><p>在类中总是将重载放在一起。</p>
<h2 id="命名规则"><a href="#命名规则" class="headerlink" title="命名规则"></a>命名规则</h2><p>Kotlin 遵循 Java 命名约定。尤其是：</p>
<p>包的名称总是小写且不使用下划线（<code>org.example.myproject</code>）。 通常不鼓励使用多个词的名称，但是如果确实需要使用多个词，可以将它们连接在一起或使用驼峰（<code>org.example.myProject</code>）。</p>
<p>类和对象的名称以大写字母开头并使用驼峰：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">open class DeclarationProcessor &#123; …… &#125;</span><br><span class="line"></span><br><span class="line">object EmptyDeclarationProcessor : DeclarationProcessor() &#123; …… &#125;</span><br></pre></td></tr></table></figure>
<h3 id="函数名"><a href="#函数名" class="headerlink" title="函数名"></a>函数名</h3><p>函数、属性与局部变量的名称以小写字母开头、使用驼峰而不使用下划线：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">fun processDeclarations() &#123; …… &#125;</span><br><span class="line">var declarationCount = ……</span><br></pre></td></tr></table></figure>
<p>例外：用于创建类实例的工厂函数可以与要创建的类具有相同的名称：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">abstract class Foo &#123; …… &#125;</span><br><span class="line"></span><br><span class="line">class FooImpl : Foo &#123; …… &#125;</span><br><span class="line"></span><br><span class="line">fun Foo(): Foo &#123; return FooImpl(……) &#125;</span><br></pre></td></tr></table></figure>
<h4 id="测试方法的名称"><a href="#测试方法的名称" class="headerlink" title="测试方法的名称"></a>测试方法的名称</h4><p>当且仅当在测试中，可以使用反引号括起来的带空格的方法名。 （请注意，Android 运行时目前不支持这样的方法名。）测试代码中也允许方法名使用下划线。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">class MyTestCase &#123;</span><br><span class="line">     @Test fun `ensure everything works`() &#123;</span><br><span class="line">     &#125;</span><br><span class="line">     </span><br><span class="line">     @Test fun ensureEverythingWorks_onAndroid() &#123;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="属性名"><a href="#属性名" class="headerlink" title="属性名"></a>属性名</h3><p>常量名称（标有 <code>const</code> 的属性，或者保存不可变数据的没有自定义 <code>get</code> 函数的顶层/对象 <code>val</code> 属性）应该使用大写、下划线分隔的名称：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const val MAX_COUNT = 8</span><br><span class="line">val USER_NAME_FIELD = &quot;UserName&quot;</span><br></pre></td></tr></table></figure>
<p>保存带有行为的对象或者可变数据的顶层/对象属性的名称应该使用常规驼峰名称：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">val mutableCollection: MutableSet&lt;String&gt; = HashSet()</span><br></pre></td></tr></table></figure>
<p>保存单例对象引用的属性的名称可以使用与 <code>object</code> 声明相同的命名风格：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">val PersonComparator: Comparator&lt;Person&gt; = ...</span><br></pre></td></tr></table></figure>
<p>对于枚举常量，可以使用大写、下划线分隔的名称 （<code>enum class Color { RED, GREEN }</code>）也可使用以大写字母开头的常规驼峰名称，具体取决于用途。</p>
<h4 id="幕后属性的名称"><a href="#幕后属性的名称" class="headerlink" title="幕后属性的名称"></a>幕后属性的名称</h4><p>如果一个类有两个概念上相同的属性，一个是公共 API 的一部分，另一个是实现细节，那么使用下划线作为私有属性名称的前缀：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">class C &#123;</span><br><span class="line">    private val _elementList = mutableListOf&lt;Element&gt;()</span><br><span class="line"></span><br><span class="line">    val elementList: List&lt;Element&gt;</span><br><span class="line">         get() = _elementList</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="选择好名称"><a href="#选择好名称" class="headerlink" title="选择好名称"></a>选择好名称</h3><p>类的名称通常是用来解释类<em>是</em>什么的名词或者名词短语：<code>List</code>、 <code>PersonReader</code>。</p>
<p>方法的名称通常是动词或动词短语，说明该方法<em>做</em>什么：<code>close</code>、 <code>readPersons</code>。 修改对象或者返回一个新对象的名称也应遵循建议。例如 <code>sort</code> 是对一个集合就地排序，而 <code>sorted</code> 是返回一个排序后的集合副本。</p>
<p>名称应该表明实体的目的是什么，所以最好避免在名称中使用无意义的单词 （<code>Manager</code>、 <code>Wrapper</code> 等）。</p>
<p>当使用首字母缩写作为名称的一部分时，如果缩写由两个字母组成，就将其大写（<code>IOStream</code>）； 而如果缩写更长一些，就只大写首首字母（<code>XmlFormatter</code>、 <code>HttpInputStream</code>）。</p>
<h2 id="格式化"><a href="#格式化" class="headerlink" title="格式化"></a>格式化</h2><p>在大多数情况下，Kotlin 遵循 Java 编码规范。</p>
<p>使用 4 个空格缩进。不要使用 tab。</p>
<p>对于花括号，将左花括号放在结构起始处的行尾，而将右花括号放在与左括结构垂直对齐的单独一行。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">if (elements != null) &#123;</span><br><span class="line">    for (element in elements) &#123;</span><br><span class="line">        // ……</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>（注意：在 Kotlin 中，分号是可选的，因此换行很重要。语言设计采用 Java 风格的花括号格式，如果尝试使用不同的格式化风格，那么可能会遇到意外的行为。）</p>
<h3 id="横向空白"><a href="#横向空白" class="headerlink" title="横向空白"></a>横向空白</h3><p>在二元操作符左右留空格（<code>a + b</code>）。例外：不要在“range to”操作符（<code>0..i</code>）左右留空格。</p>
<p>不要在一元运算符左右留空格（<code>a++</code>）</p>
<p>在控制流关键字（<code>if</code>、 <code>when</code>、 <code>for</code> 以及 <code>while</code>）与相应的左括号之间留空格。</p>
<p>不要在主构造函数声明、方法声明或者方法调用的左括号之前留空格。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">class A(val x: Int)</span><br><span class="line"></span><br><span class="line">fun foo(x: Int) &#123; &#125;</span><br><span class="line"></span><br><span class="line">fun bar() &#123;</span><br><span class="line">    foo(1)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>绝不在 <code>(</code>、 <code>[</code> 之后或者 <code>]</code>、 <code>)</code> 之前留空格。</p>
<p>绝不在<code>.</code> 或者 <code>?.</code> 左右留空格：<code>foo.bar().filter { it &gt; 2 }.joinToString()</code>, <code>foo?.bar()</code></p>
<p>在 <code>//</code> 之后留一个空格：<code>// 这是一条注释</code></p>
<p>不要在用于指定类型参数的尖括号前后留空格：<code>class Map&lt;K, V&gt; { …… }</code></p>
<p>不要在 <code>::</code> 前后留空格：<code>Foo::class</code>、 <code>String::length</code></p>
<p>不要在用于标记可空类型的 <code>?</code> 前留空格：<code>String?</code></p>
<p>作为一般规则，避免任何类型的水平对齐。将标识符重命名为不同长度的名称不应该影响声明或者任何用法的格式。</p>
<h3 id="冒号"><a href="#冒号" class="headerlink" title="冒号"></a>冒号</h3><p>在以下场景中的 <code>:</code> 之前留一个空格：</p>
<ul>
<li>当它用于分隔类型与超类型时；</li>
<li>当委托给一个超类的构造函数或者同一类的另一个构造函数时；</li>
<li>在 <code>object</code> 关键字之后。</li>
</ul>
<p>而当分隔声明与其类型时，不要在 <code>:</code> 之前留空格。</p>
<p>在 <code>:</code> 之后总要留一个空格。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">abstract class Foo&lt;out T : Any&gt; : IFoo &#123;</span><br><span class="line">    abstract fun foo(a: Int): T</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class FooImpl : Foo() &#123;</span><br><span class="line">    constructor(x: String) : this(x) &#123;</span><br><span class="line">        //……</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    val x = object : IFoo &#123; …… &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="类头格式化"><a href="#类头格式化" class="headerlink" title="类头格式化"></a>类头格式化</h3><p>具有少数主构造函数参数的类可以写成一行：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">class Person(id: Int, name: String)</span><br></pre></td></tr></table></figure>
<p>具有较长类头的类应该格式化，以使每个主构造函数参数都在带有缩进的独立的行中。 另外，右括号应该位于一个新行上。如果使用了继承，那么超类的构造函数调用或者所实现接口的列表应该与左括号位于同一行：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">class Person(</span><br><span class="line">    id: Int,</span><br><span class="line">    name: String,</span><br><span class="line">    surname: String</span><br><span class="line">) : Human(id, name) &#123;</span><br><span class="line"></span><br><span class="line">    // ……</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于多个接口，应该将超类构造函数调用放在首位，然后将每个接口应放在不同的行中：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">class Person(</span><br><span class="line">    id: Int,</span><br><span class="line">    name: String,</span><br><span class="line">    surname: String</span><br><span class="line">) : Human(id, name),</span><br><span class="line">    KotlinMaker &#123;</span><br><span class="line">    </span><br><span class="line">    // ……</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于具有很长超类型列表的类，在冒号后面换行，并垂直对齐所有超类型名：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">class MyFavouriteVeryLongClassHolder :</span><br><span class="line">    MyLongHolder&lt;MyFavouriteVeryLongClass&gt;(),</span><br><span class="line">    SomeOtherInterface,</span><br><span class="line">    AndAnotherOne &#123;</span><br><span class="line"></span><br><span class="line">    fun foo() &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>为了将类头与类体分隔清楚，当类头很长时，可以在类头后放一空行 （如上例所示）或者将左花括号放在独立行上：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">class MyFavouriteVeryLongClassHolder :</span><br><span class="line">    MyLongHolder&lt;MyFavouriteVeryLongClass&gt;(),</span><br><span class="line">    SomeOtherInterface,</span><br><span class="line">    AndAnotherOne</span><br><span class="line">&#123;</span><br><span class="line">    fun foo() &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>构造函数参数使用常规缩进（4 个空格）。</p>
<blockquote>
<p>理由：这确保了在主构造函数中声明的属性与 在类体中声明的属性具有相同的缩进。</p>
</blockquote>
<h3 id="修饰符"><a href="#修饰符" class="headerlink" title="修饰符"></a>修饰符</h3><p>如果一个声明有多个修饰符，请始终按照以下顺序安放：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public / protected / private / internal</span><br><span class="line">expect / actual</span><br><span class="line">final / open / abstract / sealed / const</span><br><span class="line">external</span><br><span class="line">override</span><br><span class="line">lateinit</span><br><span class="line">tailrec</span><br><span class="line">vararg</span><br><span class="line">suspend</span><br><span class="line">inner</span><br><span class="line">enum / annotation</span><br><span class="line">companion</span><br><span class="line">inline</span><br><span class="line">infix</span><br><span class="line">operator</span><br><span class="line">data</span><br></pre></td></tr></table></figure>
<p>将所有注解放在修饰符前：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@Named(&quot;Foo&quot;)</span><br><span class="line">private val foo: Foo</span><br></pre></td></tr></table></figure>
<p>除非你在编写库，否则请省略多余的修饰符（例如 <code>public</code>）。</p>
<h3 id="注解格式化"><a href="#注解格式化" class="headerlink" title="注解格式化"></a>注解格式化</h3><p>注解通常放在单独的行上，在它们所依附的声明之前，并使用相同的缩进：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@Target(AnnotationTarget.PROPERTY)</span><br><span class="line">annotation class JsonExclude</span><br></pre></td></tr></table></figure>
<p>无参数的注解可以放在同一行：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@JsonExclude @JvmField</span><br><span class="line">var x: String</span><br></pre></td></tr></table></figure>
<p>无参数的单个注解可以与相应的声明放在同一行：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@Test fun foo() &#123; …… &#125;</span><br></pre></td></tr></table></figure>
<h3 id="文件注解"><a href="#文件注解" class="headerlink" title="文件注解"></a>文件注解</h3><p>文件注解位于文件注释（如果有的话）之后、<code>package</code> 语句之前，并且用一个空白行与 <code>package</code> 分开（为了强调其针对文件而不是包）。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">/** 授权许可、版权以及任何其他内容 */</span><br><span class="line">@file:JvmName(&quot;FooBar&quot;)</span><br><span class="line"></span><br><span class="line">package foo.bar</span><br></pre></td></tr></table></figure>
<h3 id="函数格式化"><a href="#函数格式化" class="headerlink" title="函数格式化"></a>函数格式化</h3><p>如果函数签名不适合单行，请使用以下语法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">fun longMethodName(</span><br><span class="line">    argument: ArgumentType = defaultValue,</span><br><span class="line">    argument2: AnotherArgumentType</span><br><span class="line">): ReturnType &#123;</span><br><span class="line">    // 函数体</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>函数参数使用常规缩进（4 个空格）。</p>
<blockquote>
<p>理由：与构造函数参数一致</p>
</blockquote>
<p>对于由单个表达式构成的函数体，首选使用表达式形式。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">fun foo(): Int &#123;     // 较差</span><br><span class="line">    return 1 </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fun foo() = 1        // 良好</span><br></pre></td></tr></table></figure>
<h3 id="表达式函数体格式化"><a href="#表达式函数体格式化" class="headerlink" title="表达式函数体格式化"></a>表达式函数体格式化</h3><p>如果函数的表达式函数体与函数声明不适合放在同一行，那么将 <code>=</code> 留在第一行。 将表达式函数体缩进 4 个空格。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">fun f(x: String) =</span><br><span class="line">    x.length</span><br></pre></td></tr></table></figure>
<h3 id="属性格式化"><a href="#属性格式化" class="headerlink" title="属性格式化"></a>属性格式化</h3><p>对于非常简单的只读属性，请考虑单行格式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">val isEmpty: Boolean get() = size == 0</span><br></pre></td></tr></table></figure>
<p>对于更复杂的属性，总是将 <code>get</code> 与 <code>set</code> 关键字放在不同的行上：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">val foo: String</span><br><span class="line">    get() &#123;</span><br><span class="line">        // ……</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>对于具有初始化器的属性，如果初始化器很长，那么在等号后增加一个换行并将初始化器缩进四个空格：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">private val defaultCharset: Charset? =</span><br><span class="line">    EncodingRegistry.getInstance().getDefaultCharsetForPropertiesFiles(file)</span><br></pre></td></tr></table></figure>
<h3 id="格式化控制流语句"><a href="#格式化控制流语句" class="headerlink" title="格式化控制流语句"></a>格式化控制流语句</h3><p>如果 <code>if</code> 或 <code>when</code> 语句的条件有多行，那么在语句体外边总是使用大括号。 将该条件的每个后续行相对于条件语句起始处缩进 4 个空格。 将该条件的右圆括号与左花括号放在单独一行：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">if (!component.isSyncing &amp;&amp;</span><br><span class="line">    !hasAnyKotlinRuntimeInScope(module)</span><br><span class="line">) &#123;</span><br><span class="line">    return createKotlinNotConfiguredPanel(module)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>理由：对齐整齐并且将条件与语句体分隔清楚</p>
</blockquote>
<p>将 <code>else</code>、 <code>catch</code>、 <code>finally</code> 关键字以及 do/while 循环的 <code>while</code> 关键字与之前的花括号放在相同的行上：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">if (condition) &#123;</span><br><span class="line">    // 主体</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    // else 部分</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">try &#123;</span><br><span class="line">    // 主体</span><br><span class="line">&#125; finally &#123;</span><br><span class="line">    // 清理</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 <code>when</code> 语句中，如果一个分支不止一行，可以考虑用空行将其与相邻的分支块分开：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">private fun parsePropertyValue(propName: String, token: Token) &#123;</span><br><span class="line">    when (token) &#123;</span><br><span class="line">        is Token.ValueToken -&gt;</span><br><span class="line">            callback.visitValue(propName, token.value)</span><br><span class="line"></span><br><span class="line">        Token.LBRACE -&gt; &#123; // ……</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>将短分支放在与条件相同的行上，无需花括号。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">when (foo) &#123;</span><br><span class="line">    true -&gt; bar() // 良好</span><br><span class="line">    false -&gt; &#123; baz() &#125; // 较差</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="方法调用格式化"><a href="#方法调用格式化" class="headerlink" title="方法调用格式化"></a>方法调用格式化</h3><p>在较长参数列表的左括号后添加一个换行符。按 4 个空格缩进参数。 将密切相关的多个参数分在同一行。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">drawSquare(</span><br><span class="line">    x = 10, y = 10,</span><br><span class="line">    width = 100, height = 100,</span><br><span class="line">    fill = true</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>在分隔参数名与值的 <code>=</code> 左右留空格。</p>
<h3 id="链式调用换行"><a href="#链式调用换行" class="headerlink" title="链式调用换行"></a>链式调用换行</h3><p>当对链式调用换行时，将 . 字符或者 <code>?.</code> 操作符放在下一行，并带有单倍缩进：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">val anchor = owner</span><br><span class="line">    ?.firstChild!!</span><br><span class="line">    .siblings(forward = true)</span><br><span class="line">    .dropWhile &#123; it is PsiComment || it is PsiWhiteSpace &#125;</span><br></pre></td></tr></table></figure>
<p>调用链的第一个调用通常在换行之前，当然如果能让代码更有意义也可以忽略这点。</p>
<h3 id="Lambda-表达式格式化"><a href="#Lambda-表达式格式化" class="headerlink" title="Lambda 表达式格式化"></a>Lambda 表达式格式化</h3><p>在 lambda 表达式中，应该在花括号左右以及分隔参数与代码体的箭头左右留空格。 如果一个调用接受单个 lambda 表达式，应该尽可能将其放在圆括号外边传入。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">list.filter &#123; it &gt; 10 &#125;</span><br></pre></td></tr></table></figure>
<p>如果为 lambda 表达式分配一个标签，那么不要在该标签与左花括号之间留空格：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">fun foo() &#123;</span><br><span class="line">    ints.forEach lit@&#123;</span><br><span class="line">        // ……</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在多行的 lambda 表达式中声明参数名时，将参数名放在第一行，后跟箭头与换行符：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">appendCommaSeparated(properties) &#123; prop -&gt;</span><br><span class="line">    val propertyValue = prop.get(obj)  // ……</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果参数列表太长而无法放在一行上，请将箭头放在单独一行：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">foo &#123;</span><br><span class="line">   context: Context,</span><br><span class="line">   environment: Env</span><br><span class="line">   -&gt;</span><br><span class="line">   context.configureEnv(environment)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="文档注释"><a href="#文档注释" class="headerlink" title="文档注释"></a>文档注释</h2><p>For longer documentation comments, place the opening <code>/**</code> on a separate line and begin each subsequent line with an asterisk:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * This is a documentation comment</span><br><span class="line"> * on multiple lines.</span><br><span class="line"> */</span><br></pre></td></tr></table></figure>
<p>Short comments can be placed on a single line:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/** This is a short documentation comment. */</span><br></pre></td></tr></table></figure>
<p>Generally, avoid using <code>@param</code> and <code>@return</code> tags. Instead, incorporate the description of parameters and return values directly into the documentation comment, and add links to parameters wherever they are mentioned. Use <code>@param</code> and <code>@return</code> only when a lengthy description is required which doesn’t fit into the flow of the main text.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// Avoid doing this:</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Returns the absolute value of the given number.</span><br><span class="line"> * @param number The number to return the absolute value for.</span><br><span class="line"> * @return The absolute value.</span><br><span class="line"> */</span><br><span class="line">fun abs(number: Int) = ...</span><br><span class="line"></span><br><span class="line">// Do this instead:</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Returns the absolute value of the given [number].</span><br><span class="line"> */</span><br><span class="line">fun abs(number: Int) = ...</span><br></pre></td></tr></table></figure>
<h2 id="避免重复结构"><a href="#避免重复结构" class="headerlink" title="避免重复结构"></a>避免重复结构</h2><p>In general, if a certain syntactic construction in Kotlin is optional and highlighted by the IDE as redundant, you should omit it in your code. Do not leave unnecessary syntactic elements in code just “for clarity”.</p>
<h3 id="Unit"><a href="#Unit" class="headerlink" title="Unit"></a>Unit</h3><p>If a function returns Unit, the return type should be omitted:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fun foo() &#123; // &quot;: Unit&quot; is omitted here</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Semicolons"><a href="#Semicolons" class="headerlink" title="Semicolons"></a>Semicolons</h3><p>Omit semicolons whenever possible.</p>
<h3 id="String-templates"><a href="#String-templates" class="headerlink" title="String templates"></a>String templates</h3><p>Don’t use curly braces when inserting a simple variable into a string template. Use curly braces only for longer expressions.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">println(&quot;$name has $&#123;children.size&#125; children&quot;)</span><br></pre></td></tr></table></figure>
<h2 id="语言特性的惯用法"><a href="#语言特性的惯用法" class="headerlink" title="语言特性的惯用法"></a>语言特性的惯用法</h2><h3 id="Immutability"><a href="#Immutability" class="headerlink" title="Immutability"></a>Immutability</h3><p>Prefer using immutable data to mutable. Always declare local variables and properties as <code>val</code> rather than <code>var</code> if they are not modified after initialization.</p>
<p>Always use immutable collection interfaces (<code>Collection</code>, <code>List</code>, <code>Set</code>, <code>Map</code>) to declare collections which are not mutated. When using factory functions to create collection instances, always use functions that return immutable collection types when possible:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// Bad: use of mutable collection type for value which will not be mutated</span><br><span class="line">fun validateValue(actualValue: String, allowedValues: HashSet&lt;String&gt;) &#123; ... &#125;</span><br><span class="line"></span><br><span class="line">// Good: immutable collection type used instead</span><br><span class="line">fun validateValue(actualValue: String, allowedValues: Set&lt;String&gt;) &#123; ... &#125;</span><br><span class="line"></span><br><span class="line">// Bad: arrayListOf() returns ArrayList&lt;T&gt;, which is a mutable collection type</span><br><span class="line">val allowedValues = arrayListOf(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;)</span><br><span class="line"></span><br><span class="line">// Good: listOf() returns List&lt;T&gt;</span><br><span class="line">val allowedValues = listOf(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;)</span><br></pre></td></tr></table></figure>
<h3 id="Default-parameter-values"><a href="#Default-parameter-values" class="headerlink" title="Default parameter values"></a>Default parameter values</h3><p>Prefer declaring functions with default parameter values to declaring overloaded functions.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// Bad</span><br><span class="line">fun foo() = foo(&quot;a&quot;)</span><br><span class="line">fun foo(a: String) &#123; ... &#125;</span><br><span class="line"></span><br><span class="line">// Good</span><br><span class="line">fun foo(a: String = &quot;a&quot;) &#123; ... &#125;</span><br></pre></td></tr></table></figure>
<h3 id="Type-aliases"><a href="#Type-aliases" class="headerlink" title="Type aliases"></a>Type aliases</h3><p>If you have a functional type or a type with type parameters which is used multiple times in a codebase, prefer defining a type alias for it:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">typealias MouseClickHandler = (Any, MouseEvent) -&gt; Unit</span><br><span class="line">typealias PersonIndex = Map&lt;String, Person&gt;</span><br></pre></td></tr></table></figure>
<h3 id="Lambda-parameters"><a href="#Lambda-parameters" class="headerlink" title="Lambda parameters"></a>Lambda parameters</h3><p>In lambdas which are short and not nested, it’s recommended to use the <code>it</code> convention instead of declaring the parameter explicitly. In nested lambdas with parameters, parameters should be always declared explicitly.</p>
<h3 id="Returns-in-a-lambda"><a href="#Returns-in-a-lambda" class="headerlink" title="Returns in a lambda"></a>Returns in a lambda</h3><p>Avoid using multiple labeled returns in a lambda. Consider restructuring the lambda so that it will have a single exit point. If that’s not possible or not clear enough, consider converting the lambda into an anonymous function.</p>
<p>Do not use a labeled return for the last statement in a lambda.</p>
<h3 id="Named-arguments"><a href="#Named-arguments" class="headerlink" title="Named arguments"></a>Named arguments</h3><p>Use the named argument syntax when a method takes multiple parameters of the same primitive type, or for parameters of <code>Boolean</code> type, unless the meaning of all parameters is absolutely clear from context.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">drawSquare(x = 10, y = 10, width = 100, height = 100, fill = true)</span><br></pre></td></tr></table></figure>
<h3 id="Using-conditional-statements"><a href="#Using-conditional-statements" class="headerlink" title="Using conditional statements"></a>Using conditional statements</h3><p>Prefer using the expression form of <code>try</code>, <code>if</code> and <code>when</code>. Examples:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">return if (x) foo() else bar()</span><br><span class="line"></span><br><span class="line">return when(x) &#123;</span><br><span class="line">    0 -&gt; &quot;zero&quot;</span><br><span class="line">    else -&gt; &quot;nonzero&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>The above is preferable to:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">if (x)</span><br><span class="line">    return foo()</span><br><span class="line">else</span><br><span class="line">    return bar()</span><br><span class="line">    </span><br><span class="line">when(x) &#123;</span><br><span class="line">    0 -&gt; return &quot;zero&quot;</span><br><span class="line">    else -&gt; return &quot;nonzero&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="if-versus-when"><a href="#if-versus-when" class="headerlink" title="if versus when"></a><code>if</code> versus <code>when</code></h3><p>Prefer using <code>if</code> for binary conditions instead of <code>when</code>. Instead of</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">when (x) &#123;</span><br><span class="line">    null -&gt; ...</span><br><span class="line">    else -&gt; ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>use <code>if (x == null) ... else ...</code></p>
<p>Prefer using <code>when</code> if there are three or more options.</p>
<h3 id="Using-nullable-Boolean-values-in-conditions"><a href="#Using-nullable-Boolean-values-in-conditions" class="headerlink" title="Using nullable Boolean values in conditions"></a>Using nullable <code>Boolean</code> values in conditions</h3><p>If you need to use a nullable <code>Boolean</code> in a conditional statement, use <code>if (value == true)</code> or <code>if (value == false)</code> checks.</p>
<h3 id="Using-loops"><a href="#Using-loops" class="headerlink" title="Using loops"></a>Using loops</h3><p>Prefer using higher-order functions (<code>filter</code>, <code>map</code> etc.) to loops. Exception: <code>forEach</code> (prefer using a regular <code>for</code> loop instead, unless the receiver of <code>forEach</code> is nullable or <code>forEach</code> is used as part of a longer call chain).</p>
<p>When making a choice between a complex expression using multiple higher-order functions and a loop, understand the cost of the operations being performed in each case and keep performance considerations in mind.</p>
<h3 id="Loops-on-ranges"><a href="#Loops-on-ranges" class="headerlink" title="Loops on ranges"></a>Loops on ranges</h3><p>Use the <code>until</code> function to loop over an open range:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">for (i in 0..n - 1) &#123; ... &#125;  // bad</span><br><span class="line">for (i in 0 until n) &#123; ... &#125;  // good</span><br></pre></td></tr></table></figure>
<h3 id="Using-strings"><a href="#Using-strings" class="headerlink" title="Using strings"></a>Using strings</h3><p>Prefer using string templates to string concatenation.</p>
<p>Prefer to use multiline strings instead of embedding <code>\n</code> escape sequences into regular string literals.</p>
<p>To maintain indentation in multiline strings, use <code>trimIndent</code> when the resulting string does not require any internal indentation, or <code>trimMargin</code> when internal indentation is required:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">assertEquals(&quot;&quot;&quot;Foo</span><br><span class="line">                Bar&quot;&quot;&quot;.trimIndent(), value)</span><br><span class="line"></span><br><span class="line">val a = &quot;&quot;&quot;if(a &gt; 1) &#123;</span><br><span class="line">          |    return a</span><br><span class="line">          |&#125;&quot;&quot;&quot;.trimMargin()</span><br></pre></td></tr></table></figure>
<h3 id="Functions-vs-Properties"><a href="#Functions-vs-Properties" class="headerlink" title="Functions vs Properties"></a>Functions vs Properties</h3><p>In some cases functions with no arguments might be interchangeable with read-only properties. Although the semantics are similar, there are some stylistic conventions on when to prefer one to another.</p>
<p>Prefer a property over a function when the underlying algorithm:</p>
<ul>
<li>does not throw</li>
<li>is cheap to calculate (or caсhed on the first run)</li>
<li>returns the same result over invocations if the object state hasn’t changed</li>
</ul>
<h3 id="Using-extension-functions"><a href="#Using-extension-functions" class="headerlink" title="Using extension functions"></a>Using extension functions</h3><p>Use extension functions liberally. Every time you have a function that works primarily on an object, consider making it an extension function accepting that object as a receiver. To minimize API pollution, restrict the visibility of extension functions as much as it makes sense. As necessary, use local extension functions, member extension functions, or top-level extension functions with private visibility.</p>
<h3 id="Using-infix-functions"><a href="#Using-infix-functions" class="headerlink" title="Using infix functions"></a>Using infix functions</h3><p>Declare a function as infix only when it works on two objects which play a similar role. Good examples: <code>and</code>, <code>to</code>, <code>zip</code>. Bad example: <code>add</code>.</p>
<p>Don’t declare a method as infix if it mutates the receiver object.</p>
<h3 id="Factory-functions"><a href="#Factory-functions" class="headerlink" title="Factory functions"></a>Factory functions</h3><p>If you declare a factory function for a class, avoid giving it the same name as the class itself. Prefer using a distinct name making it clear why the behavior of the factory function is special. Only if there is really no special semantics, you can use the same name as the class.</p>
<p>Example:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">class Point(val x: Double, val y: Double) &#123;</span><br><span class="line">    companion object &#123;</span><br><span class="line">        fun fromPolar(angle: Double, radius: Double) = Point(...)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>If you have an object with multiple overloaded constructors that don’t call different superclass constructors and can’t be reduced to a single constructor with default argument values, prefer to replace the overloaded constructors with factory functions.</p>
<h3 id="Platform-types"><a href="#Platform-types" class="headerlink" title="Platform types"></a>Platform types</h3><p>A public function/method returning an expression of a platform type must declare its Kotlin type explicitly:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fun apiCall(): String = MyJavaApi.getProperty(&quot;name&quot;)</span><br></pre></td></tr></table></figure>
<p>Any property (package-level or class-level) initialised with an expression of a platform type must declare its Kotlin type explicitly:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">class Person &#123;</span><br><span class="line">    val name: String = MyJavaApi.getProperty(&quot;name&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>A local value initialised with an expression of a platform type may or may not have a type declaration:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">fun main(args: Array&lt;String&gt;) &#123;</span><br><span class="line">    val name = MyJavaApi.getProperty(&quot;name&quot;)</span><br><span class="line">    println(name)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Using-scope-functions-apply-with-run-also-let"><a href="#Using-scope-functions-apply-with-run-also-let" class="headerlink" title="Using scope functions apply/with/run/also/let"></a>Using scope functions apply/with/run/also/let</h3><p>Kotlin provides a variety of functions to execute a block of code in the context of a given object. To choose the correct function, consider the following:</p>
<ul>
<li>Are you calling methods on multiple objects in the block, or passing the instance of the context object as an argument? If you are, use one of the functions that allows you to access the context object as <code>it</code>, not <code>this</code> (<code>also</code> or <code>let</code>). Use <code>also</code> if the receiver is not used at all in the block.</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">// Context object is &apos;it&apos;</span><br><span class="line">class Baz &#123;</span><br><span class="line">    var currentBar: Bar?</span><br><span class="line">    val observable: Observable</span><br><span class="line"></span><br><span class="line">    val foo = createBar().also &#123;</span><br><span class="line">        currentBar = it                    // Accessing property of Baz</span><br><span class="line">        observable.registerCallback(it)    // Passing context object as argument</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Receiver not used in the block</span><br><span class="line">val foo = createBar().also &#123;</span><br><span class="line">    LOG.info(&quot;Bar created&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Context object is &apos;this&apos;</span><br><span class="line">class Baz &#123;</span><br><span class="line">    val foo: Bar = createBar().apply &#123;</span><br><span class="line">        color = RED    // Accessing only properties of Bar</span><br><span class="line">        text = &quot;Foo&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>What should the result of the call be? If the result needs to be the context object, use <code>apply</code> or <code>also</code>. If you need to return a value from the block, use <code>with</code>, <code>let</code> or <code>run</code></li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// Return value is context object</span><br><span class="line">class Baz &#123;</span><br><span class="line">    val foo: Bar = createBar().apply &#123;</span><br><span class="line">        color = RED    // Accessing only properties of Bar</span><br><span class="line">        text = &quot;Foo&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// Return value is block result</span><br><span class="line">class Baz &#123;</span><br><span class="line">    val foo: Bar = createNetworkConnection().let &#123;</span><br><span class="line">        loadBar()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>Is the context object nullable, or is it evaluated as a result of a call chain? If it is, use <code>apply</code>, <code>let</code> or <code>run</code>. Otherwise, use <code>with</code> or <code>also</code>.</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// Context object is nullable</span><br><span class="line">person.email?.let &#123; sendEmail(it) &#125;</span><br><span class="line"></span><br><span class="line">// Context object is non-null and accessible directly</span><br><span class="line">with(person) &#123;</span><br><span class="line">    println(&quot;First name: $firstName, last name: $lastName&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="库的编码规范"><a href="#库的编码规范" class="headerlink" title="库的编码规范"></a>库的编码规范</h2><p>When writing libraries, it’s recommended to follow an additional set of rules to ensure API stability:</p>
<ul>
<li>Always explicitly specify member visibility (to avoid accidentally exposing declarations as public API)</li>
<li>Always explicitly specify function return types and property types (to avoid accidentally changing the return type when the implementation changes)</li>
<li>Provide KDoc comments for all public members, with the exception of overrides that do not require any new documentation (to support generating documentation for the library)</li>
</ul>

        </div>
        <footer class="article-footer">
            
    <div class="jiathis_style">
    <span class="jiathis_txt">分享到：</span>
    <a class="jiathis_button_qzone">QQ空间</a>
    <a class="jiathis_button_tsina">新浪微博</a>
    <a class="jiathis_button_tqq">腾讯微博</a>
    <a class="jiathis_button_weixin">微信</a>
    <a href="http://www.jiathis.com/share" class="jiathis jiathis_txt jiathis_separator jtico jtico_jiathis" target="_blank">更多</a>
    <a class="jiathis_counter_style"></a>
</div>
<script type="text/javascript" src="http://v3.jiathis.com/code/jia.js" charset="utf-8"></script>
<style>
    .jiathis_style div:first-child:not(.jiadiv_01) {
        width: auto !important;
        border: none !important;
    }
    .jiathis_style .jiadiv_01 {
        margin: 10px 0;
        border-radius: 4px;
        border: #e1e1e1 solid 1px;
    }
    .jiathis_style .jiadiv_01 div:first-child {
        display: none;
    }
    .jiathis_style .jiadiv_02 {
        padding: 7px 0 !important;
    }
    .jiathis_style .jiadiv_02 .jiatitle {
        width: 85px;
        border: none;
        height: auto;
        margin: 3px 10px;
        padding: 6px 10px;
        border-radius: 4px;
    }
    .jiathis_style .jiadiv_02 .jiatitle:hover {
        border: none;
    }
    .jiathis_style .jiadiv_02 .jiatitle:nth-child(even) {
        margin-left: 0;
    }
    .jiathis_style .jtico:hover {
        opacity: 1;
    }
    .jiathis_style .ckepopBottom,
    .jiathis_style .centerBottom {
        width: auto !important;
        padding: 5px;
        background: #f7f7f7;
    }
</style>




        </footer>
    </div>
</article>
<!-- 来必力City版安装代码 -->
<div id="lv-container" data-id="city" data-uid="MTAyMC8zMjA1Ni84NjIw">
	<script type="text/javascript">
   (function(d, s) {
       var j, e = d.getElementsByTagName(s)[0];

       if (typeof LivereTower === 'function') { return; }

       j = d.createElement(s);
       j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
       j.async = true;

       e.parentNode.insertBefore(j, e);
   })(document, 'script');
	</script>
<noscript> 为正常使用来必力评论功能请激活JavaScript</noscript>
</div>
<!-- City版安装代码已完成 -->

                        </div>
                    </section>
                    <aside id="sidebar">
    <a class="sidebar-toggle" title="Expand Sidebar"><i class="toggle icon"></i></a>
    <div class="sidebar-top">
        <p>关注我 :</p>
        <ul class="social-links">
            
                
                <li>
                    <a class="social-tooltip" title="github" href="https://github.com/xuer80" target="_blank">
                        <i class="icon fa fa-github"></i>
                    </a>
                </li>
                
            
        </ul>
    </div>
    
        
<nav id="article-nav">
    
    
        <a href="/2018/04/27/第二章-Kotlin习惯用法/" id="article-nav-older" class="article-nav-link-wrap">
        <strong class="article-nav-caption">上一篇</strong>
        <p class="article-nav-title">第二章-Kotlin习惯用法</p>
        <i class="icon fa fa-chevron-left" id="icon-chevron-left"></i>
        </a>
    
</nav>

    
    <div class="widgets-container">
        
            
                
    <div class="widget-wrap">
        <h3 class="widget-title">最新文章</h3>
        <div class="widget">
            <ul id="recent-post" class="no-thumbnail">
                
                    <li>
                        
                        <div class="item-inner">
                            <p class="item-category"><a class="article-category-link" href="/categories/编程语言/">编程语言</a><i class="icon fa fa-angle-right"></i><a class="article-category-link" href="/categories/编程语言/Kotlin/">Kotlin</a></p>
                            <p class="item-title"><a href="/2018/04/27/第三章-Kotlin编码规范/" class="title">第三章-Kotlin编码规范</a></p>
                            <p class="item-date"><time datetime="2018-04-27T15:21:25.000Z" itemprop="datePublished">2018-04-27</time></p>
                        </div>
                    </li>
                
                    <li>
                        
                        <div class="item-inner">
                            <p class="item-category"><a class="article-category-link" href="/categories/编程语言/">编程语言</a><i class="icon fa fa-angle-right"></i><a class="article-category-link" href="/categories/编程语言/Kotlin/">Kotlin</a></p>
                            <p class="item-title"><a href="/2018/04/27/第二章-Kotlin习惯用法/" class="title">第二章-Kotlin习惯用法</a></p>
                            <p class="item-date"><time datetime="2018-04-27T14:53:22.000Z" itemprop="datePublished">2018-04-27</time></p>
                        </div>
                    </li>
                
                    <li>
                        
                        <div class="item-inner">
                            <p class="item-category"></p>
                            <p class="item-title"><a href="/2018/04/27/Android活动Activity/" class="title">Android活动Activity</a></p>
                            <p class="item-date"><time datetime="2018-04-27T00:59:19.000Z" itemprop="datePublished">2018-04-27</time></p>
                        </div>
                    </li>
                
                    <li>
                        
                        <div class="item-inner">
                            <p class="item-category"><a class="article-category-link" href="/categories/Android/">Android</a><i class="icon fa fa-angle-right"></i><a class="article-category-link" href="/categories/Android/Android应用层/">Android应用层</a></p>
                            <p class="item-title"><a href="/2018/04/27/Android四大组件概述/" class="title">Android四大组件概述</a></p>
                            <p class="item-date"><time datetime="2018-04-27T00:58:38.000Z" itemprop="datePublished">2018-04-27</time></p>
                        </div>
                    </li>
                
                    <li>
                        
                        <div class="item-inner">
                            <p class="item-category"><a class="article-category-link" href="/categories/编程语言/">编程语言</a><i class="icon fa fa-angle-right"></i><a class="article-category-link" href="/categories/编程语言/Kotlin/">Kotlin</a></p>
                            <p class="item-title"><a href="/2018/04/26/第一章-kotlin基础语法/" class="title">第一章-kotlin基础语法</a></p>
                            <p class="item-date"><time datetime="2018-04-26T12:53:01.000Z" itemprop="datePublished">2018-04-26</time></p>
                        </div>
                    </li>
                
            </ul>
        </div>
    </div>

            
                
    <div class="widget-wrap widget-list">
        <h3 class="widget-title">分类</h3>
        <div class="widget">
            <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Android/">Android</a><span class="category-list-count">3</span><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/Android/Android应用层/">Android应用层</a><span class="category-list-count">2</span><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/Android/Android应用层/Android四大组件/">Android四大组件</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Android/Android应用层/Android架构/">Android架构</a><span class="category-list-count">1</span></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/Android/Android框架层/">Android框架层</a><span class="category-list-count">1</span><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/Android/Android框架层/Android系统架构/">Android系统架构</a><span class="category-list-count">1</span></li></ul></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/屠龙技/">屠龙技</a><span class="category-list-count">27</span><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/屠龙技/数据结构与算法/">数据结构与算法</a><span class="category-list-count">2</span><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/屠龙技/数据结构与算法/数据结构/">数据结构</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/屠龙技/数据结构与算法/算法/">算法</a><span class="category-list-count">1</span></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/屠龙技/设计模式/">设计模式</a><span class="category-list-count">25</span></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/开发工具/">开发工具</a><span class="category-list-count">5</span><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/开发工具/AndroidStudio/">AndroidStudio</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/开发工具/Git/">Git</a><span class="category-list-count">1</span></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/操作系统/">操作系统</a><span class="category-list-count">2</span><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/操作系统/Linux/">Linux</a><span class="category-list-count">2</span><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/操作系统/Linux/linux基础/">linux基础</a><span class="category-list-count">2</span></li></ul></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/散文/">散文</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/编程语言/">编程语言</a><span class="category-list-count">9</span><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/编程语言/C/">C</a><span class="category-list-count">3</span><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/编程语言/C/C-Primer-Plus/">C Primer Plus</a><span class="category-list-count">3</span></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/编程语言/Java/">Java</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/编程语言/Kotlin/">Kotlin</a><span class="category-list-count">3</span><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/编程语言/Kotlin/认识Kotlin/">认识Kotlin</a><span class="category-list-count">3</span></li></ul></li></ul></li></ul>
        </div>
    </div>


            
                
    <div class="widget-wrap widget-list">
        <h3 class="widget-title">归档</h3>
        <div class="widget">
            <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/04/">四月 2018</a><span class="archive-list-count">13</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/03/">三月 2018</a><span class="archive-list-count">4</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/01/">一月 2018</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/12/">十二月 2017</a><span class="archive-list-count">16</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/11/">十一月 2017</a><span class="archive-list-count">13</span></li></ul>
        </div>
    </div>


            
                
    <div class="widget-wrap widget-float">
        <h3 class="widget-title">标签云</h3>
        <div class="widget tagcloud">
            <a href="/tags/AndroidStudio/" style="font-size: 16.67px;">AndroidStudio</a> <a href="/tags/Android架构/" style="font-size: 13.33px;">Android架构</a> <a href="/tags/C/" style="font-size: 16.67px;">C</a> <a href="/tags/Hexo/" style="font-size: 10px;">Hexo</a> <a href="/tags/Java/" style="font-size: 16.67px;">Java</a> <a href="/tags/git/" style="font-size: 10px;">git</a> <a href="/tags/kotlin/" style="font-size: 16.67px;">kotlin</a> <a href="/tags/linux/" style="font-size: 13.33px;">linux</a> <a href="/tags/四大组件/" style="font-size: 10px;">四大组件</a> <a href="/tags/散文/" style="font-size: 13.33px;">散文</a> <a href="/tags/数据结构/" style="font-size: 13.33px;">数据结构</a> <a href="/tags/设计模式/" style="font-size: 20px;">设计模式</a>
        </div>
    </div>


            
                
    <div class="widget-wrap widget-list">
        <h3 class="widget-title">链接</h3>
        <div class="widget">
            <ul>
                
                    <li>
                        <a href="http://hexo.io">Hexo</a>
                    </li>
                
            </ul>
        </div>
    </div>


            
        
    </div>
</aside>
                </div>
            </div>
        </div>
        <footer id="footer">
    <div class="container">
        <div class="container-inner">
            <a id="back-to-top" href="javascript:;"><i class="icon fa fa-angle-up"></i></a>
            <div class="credit">
                <h1 class="logo-wrap">
                    <a href="/" class="logo"></a>
                </h1>
                <p>&copy; 2018 xuer80</p>
                <p>Powered by <a href="//hexo.io/" target="_blank">Hexo</a>. Theme by <a href="//github.com/ppoffice" target="_blank">PPOffice</a></p>
            </div>
        </div>
    </div>
</footer>
        
    
    <script>
    var disqus_shortname = 'hexo-theme-hueman';
    
    
    var disqus_url = 'http://xuer80.com/2018/04/27/第三章-Kotlin编码规范/';
    
    (function() {
    var dsq = document.createElement('script');
    dsq.type = 'text/javascript';
    dsq.async = true;
    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
    </script>




    
        <script src="/libs/lightgallery/js/lightgallery.min.js"></script>
        <script src="/libs/lightgallery/js/lg-thumbnail.min.js"></script>
        <script src="/libs/lightgallery/js/lg-pager.min.js"></script>
        <script src="/libs/lightgallery/js/lg-autoplay.min.js"></script>
        <script src="/libs/lightgallery/js/lg-fullscreen.min.js"></script>
        <script src="/libs/lightgallery/js/lg-zoom.min.js"></script>
        <script src="/libs/lightgallery/js/lg-hash.min.js"></script>
        <script src="/libs/lightgallery/js/lg-share.min.js"></script>
        <script src="/libs/lightgallery/js/lg-video.min.js"></script>
    
    
        <script src="/libs/justified-gallery/jquery.justifiedGallery.min.js"></script>
    
    



<!-- Custom Scripts -->
<script src="/js/main.js"></script>

    </div>
</body>
</html>
